GoodbyeDPI — инструмент для обхода DPI, систем "глубокого анализа трафика"
=========================

Эта программа предназначена для обхода ограничений систем DPI применяемых многими интернет-провайдерами для блокировки определённых сайтов и сервисов.

Программа умеет работать как с **пассивными DPI** (подключаются в сплит трафика или зеркалируют порты сервисов; такие DPI не блокируют трафик, но лишь отвечают быстрее чем запрашиваемый ресурс), так и с **активными DPI**, подключенными последовательно.

Для работы программы требуется **Windows 7, 8, 8.1, 10 или 11** и учётная запись с правами администратора.

# Краткая инструкция

* **Для пользователей в России**: скачайте [последнюю версию со страницы релизов](https://github.com/ValdikSS/GoodbyeDPI/releases), распакуйте архив и запустите скрипт **1_russia_blacklist_dnsredir.cmd**.
* **Обход замедления YouTube в России**: ознакомьтесь с актуальными инструкциями и часто задаваемыми вопросами [здесь](https://github.com/ValdikSS/GoodbyeDPI/issues/378)
* Для пользователей в других странах: скачайте [последнюю версию со страницы релизов](https://github.com/ValdikSS/GoodbyeDPI/releases), распакуйте архив и запустите скрипт **2_any_country_dnsredir.cmd**.

Указанные выше скрипты запускают GoodbyeDPI с рекомендуемыми настройками и переадресовывают DNS-запросы на серверы Яндекса (позволяет избежать подмены ответов DNS)

Если всё заработало с первого раза - поздравляем! Если же программа запустилась, но заблокированные ресурсы по-прежнему недоступны - ознакомьтесь с документацией ниже и измените стандартные настройки.

# Как пользоваться программой

Скачайте [последнюю версию со страницы релизов](https://github.com/ValdikSS/GoodbyeDPI/releases) и запустите её

```
Как запускать: goodbyedpi.exe [ОПЦИИ...]
 -p                блокировать работу пассивных DPI
 -q                блокировать протоколы QUIC/HTTP3
 -r                заменить Host with hoSt
 -s                удалить пробелы между заголовком Host и его значением
 -m                перемешать регистр в заголовке Host (test.com -> tEsT.cOm)
 -f <количество>   разбивать HTTP на <количество> фрагментов
 -k <количество>   включить постоянное (keep-alive) разбиение HTTP запросов на <количество> фрагментов
 -n                не дожидаться первого сегмента ACK когда используется ключ -k
 -e <количество>   разбивать HTTPS на <количество> фрагментов
 -a                добавлять дополнительный пробел между Method и Request-URI (автоматически включает ключ -s, может сломать некоторые сайты)
 -w                пытаться искать и обрабатывать HTTP трафик на всех доступных портах (не только на порту 80)
 --port        <значение>  указать дополнительный TCP-порт на котором нужно производить разбиение трафика (и хитрить с HTTP как в случае с ключом -w)
 --ip-id       <значение>  обрабатывать дополнительный IP ID (значение должно быть десятичным число; позволяет сбрасывать редиректы и TCP RST для этого ID).
                           Эту опцию можно передавать несколько раз.
 --dns-addr    <значение>  перенаправлять DNS-запросы передаваемые по UDP на указанный IPv4 адрес (экспериментальная опция)
 --dns-port    <значение>  перенаправлять DNS-запросы передаваемые по UDP на указанный порт IPv6 адреса (по умолчанию - порт 53)
 --dnsv6-addr  <значение>  перенаправлять DNS-запросы передаваемые по UDP на указанный IPv6 адрес (экспериментальная опция)
 --dnsv6-port  <значение>  перенаправлять DNS-запросы передаваемые по UDP на указанный порт IPv6 адреса (по умолчанию - порт 53)
 --dns-verb                выводить в лог более подробные сообщения о перенаправлении DNS
 --blacklist   <текстовый файл>  пытаться обходить блокировки только для доменных имён и поддоменов указанных в текстовом файле (HTTP Host/TLS SNI)
                                 Эту опцию можно передавать несколько раз.
 --allow-no-sni                  пытаться обходить блокировки, если TLS SNI не может быть определён со включенной опцией --blacklist
 --frag-by-sni                   если SNI обнаружен в TLS-пакете - разбивать пакет непосредственно перед значением SNI
 --set-ttl     <значение>        активировать режим Fake Request и передавать его с указанным значением TTL
                                 ОПАСНО! Может сломать различные сайты в самых неожиданных местах. Применяйте с осторожностью (или пользуйтесь опцией --blacklist)
 --auto-ttl    [a1-a2-m]         активировать режим Fake Request, автоматически определять TTL и понижать значение TTL, основываясь на расстоянии до цели.
                                 Например, если расстояние меньше чем a2, TTL понижается на a2. Если расстояние больше, то используется шкала (a1; a2) с учётом расстояния как веса.
                                 Если итоговый TTL больше чем m(ax), установите его как m
                                 Значения по умолчанию: --auto-ttl 1-4-10. Также включает опцию: --min-ttl 3.
                                 ОПАСНО! Может сломать различные сайты в самых неожиданных местах. Применяйте с осторожностью (или пользуйтесь опцией --blacklist)
 --min-ttl     <значение>        минимальное расстояние TTL (128/64 - TTL) для которого нужно передавать Fake Request в режимах --set-ttl и --auto-ttl
 --wrong-chksum                  активировать режим Fake Request и отправлять TCP-пакеты с некорректной контрольной суммой
                                 Может не работать так как задумано в виртуальных машинах или с некоторыми роутерами - но эта опция безопаснее, чем --set-ttl
 --wrong-seq                     включить режим Fake Request и отправлять TCP с тайстампами для SEQ/ACK в прошлом
 --native-frag                   разбивать пакеты на более мелкие, не уменьшая размер TCP окна (Window Size); не приводит к дополнительным задержкам в соединении.
 --reverse-frag                  разбивать пакеты так же, как делает опция --native-frag, но отправлять их в обратном порядке; работает с сайтами, которые некорректно
                                 обрабатывают разбитый на фрагменты HTTPS TLS ClientHello
 --fake-from-hex <значение>      загружать фальшивые пакеты для режима Fake Request из шестнадцатиричных значений (например, 1234abcDEF).
                                 Эту опцию можно передавать несколько раз. В таком случае, каждый фальшивый пакет будет отправлен при каждом запросе, в порядке
                                 указания аргументов в командной строке.
 --fake-gen <значение>           генерировать случайные фальшивые пакеты для режима Fake Request (до 30)
 --fake-resend <количество>      отправлять каждый фальшивый пакет <количество> раз.
                                 По умолчанию, каждый пакет отправляется один раз.
 --max-payload [значение]        не обрабатывать пакеты с TCP-содержимым большим по объёму чем [значение]
                                 Использование этой опции позволяет снизить нагрузку на CPU, не обрабатывая большие объёмы данных (например передачу файлов)
                                 передаваемые через уже успешно установленные соединениях. Позволяет не обрабатывать большие HTTP-запросы.
                                 Если опция включена, значение по умолчанию равняется 1200 байт.

Устаревшие режимы:
 -1          -p -r -s -f 2 -k 2 -n -e 2 (наилучшая совместимость)
 -2          -p -r -s -f 2 -k 2 -n -e 40 (улучшает скорости для HTTPS, но все ещё не ломает совместимость)
 -3          -p -r -s -e 40 (ещё лучше скорости для HTTP и HTTPS)
 -4          -p -r -s (самая высокая скорость)

Актуальные режимы (более стабильны, лучше совместимость, быстрее):
 -5          -f 2 -e 2 --auto-ttl --reverse-frag --max-payload
 -6          -f 2 -e 2 --wrong-seq --reverse-frag --max-payload
 -7          -f 2 -e 2 --wrong-chksum --reverse-frag --max-payload
 -8          -f 2 -e 2 --wrong-seq --wrong-chksum --reverse-frag --max-payload
 -9          -f 2 -e 2 --wrong-seq --wrong-chksum --reverse-frag --max-payload -q (this is the default)

 Внимание: сочетаниен опций --wrong-seq и --wrong-chksum сгенерирует два разных фальшивых пакета.
```

Чтобы проверить, что DPI вашего провайдера можно обойти, сначала убедитесь что провайдер не подменяет DNS-запросы. Это можно сделать включив режим "Защищённый DNS (DNS over HTTPS) в вашем браузере.

* **Chrome**: Настройки → [Конфиденциальность и безопасность](chrome://settings/security) → Использовать безопасный DNS-сервер → Использовать: NextDNS
* **Firefox**: [Настройки](about:preferences) → Параметры сети → Включить DNS через HTTPS → Используемый провайдер: NextDNS

После этого запустите исполняемый файл `goodbyedpi.exe` не передавая ему никаких опций. Если всё заработало с первого раза - поздравляем! Вы можете пользоваться программой с настройками по умолчанию или передать дополнительные опции, например  `--blacklist` - если вам доступен список заблокированных в вашей стране сайтов.

Если ваш провайдер подменяет DNS-запросы, вы можете воспользоваться опцией `--dns-addr`, указав на публичный DNS-сервер работающий на нестандартном порту (например, Яндекс DNS `77.88.8.8:1253`). Также вы можете настроить работу DNS через HTTPS или TLS при помощи сторонних приложений.

Ознакомьтесь со скриптами запуска программы (.cmd) и измените их в соответствии со своими предпочтениями и тем, как ваш провайдер осуществляет блокировки.

# Как это всё работает

### Пассивные DPI

Когда вы пытаетесь обратиться к заблокированному сайту через HTTP, большинство пассивных DP отправляют HTTP-ответ 302 Redirect (или TCP Reset в случае с HTTPS), делая это быстрее чем ответил бы настоящий сайт. Пакеты отправляемые такими DPI как правило содержат в поле IP Identification значения `0x0000` или `0x0001` (в случае с российскими провайдерами). Если такие пакеты пытаются перенаправлять пользователя на другой сайт (например, заглушку с сообщением о блокировке), GoodbyeDPI отбрасывает их.

### Активные DPI

Обмануть активные DPI более сложно. На данный момент программой используются семь способов их обхода:

* Разбивка первого пакета на уровне TCP
* Разбивка первого пакета на уровне TCP для постоянных (keep-alive) HTTP-сессий
* Подмена имени заголовка `Host` на `hoSt`
* Удаление пробела в заголовке `Host` между именем заголовка и его значением
* Добавление дополнительного пробела между HTTP-методами (GET, POST и так далее) и самим URI
* Перемешивание регистра значения заголовка `Host`
* Отправка фальшивых HTTP/HTTPS пакетов с низким значением TTL (Time-To-Live), некорректной контрольной суммой или некорректными значениями TCP Sequence/Acknowledgement

Эти способы обхода не нарушают работу тех сайтов, что полностью совместимы со стандартами TCP и HTTP, однако достаточно сильно мешают распознаванию трафика системами DPI, и тем самым позволяют обходить государственную цензуру. Хотя добавление дополнительных пробелов и может нарушить работу некоторых сайтов, это является допустимым с точки зрения спецификации HTTP/1.1 (см. 19.3 Tolerant Applications).

При запуске эта программа загружает драйвер WinDivert, который использует платформу фильтрации Windows (Windows Filtering Platform) для настройки фильтров и позволяет обрабатывать пакеты в пространстве пользователя. Драйвер продолжает работу до тех пор, пока активно окно командной строки программы, и прекращает работу вместе с его закрытием автоматически.

# Как скомпилировать программу

Программа копилируется при помощи **GNU Make** и [**mingw**](https://mingw-w64.org). Единственная зависимость - [WinDivert](https://github.com/basil00/Divert).

Чтобы собрать исполняемый файл для 32-битных платформ, выполните команду:

`make CPREFIX=i686-w64-mingw32- WINDIVERTHEADERS=/path/to/windivert/include WINDIVERTLIBS=/path/to/windivert/x86`

Чтобы собрать исполняемый файл для 64-битных платформ, выполните команду:

`make CPREFIX=x86_64-w64-mingw32- BIT64=1 WINDIVERTHEADERS=/path/to/windivert/include WINDIVERTLIBS=/path/to/windivert/amd64`

# Как установить программу в качестве системного сервиса

Ознакомьтесь с содержимым скриптов `service_install_russia_blacklist.cmd`, `service_install_russia_blacklist_dnsredir.cmd` и `service_remove.cmd`, и используйте их в качестве примера.

# Известные проблемы

* Если ваша копия Windows 7 очень давно не обновлялась, система может отказаться загружать драйвер WinDivert может отказаться в ней поддержки алгоритма SHA256, который используется в цифровой подписи драйвера. Чтобы решить эту проблему, установите вручную обновление KB3033929 ([32-битные системы](https://www.microsoft.com/en-us/download/details.aspx?id=46078) / [64-битные системы](https://www.microsoft.com/en-us/download/details.aspx?id=46148), а ещё лучше - обновите всю систему полностью при помощи Центра обновления Windows.
* Сетевые адаптеры Intel/Qualcomm Killer: настройка `Advanced Stream Detect` в Killer Control Center несовместима с GoodbyeDPI, [её нужно отключить](https://github.com/ValdikSS/GoodbyeDPI/issues/541#issuecomment-2296038239).
* ~~Некоторые стеки SSL/TLS неспособны обрабатывать разбитые на части пакеты ClientHello, и сайты с HTTPS не открываются. Номера багов: [#4](https://github.com/ValdikSS/GoodbyeDPI/issues/4), [#64](https://github.com/ValdikSS/GoodbyeDPI/issues/64).~~ Проблемы с разбивкой пакетов решены в версии 0.1.7
* ~~Антивирус ESET несовместим с драйвером WinDivert [#91](https://github.com/ValdikSS/GoodbyeDPI/issues/91). Скорее всего, проблема не в драйвере, а в антивирусе.~~


# Похожие проекты

- **[zapret](https://github.com/bol-van/zapret)** от @bol-van (для MacOS, Linux and Windows)
- **[Green Tunnel](https://github.com/SadeghHayeri/GreenTunnel)** от @SadeghHayeri (для MacOS, Linux и Windows)
- **[DPI Tunnel CLI](https://github.com/nomoresat/DPITunnel-cli)** от @zhenyolka (для Linux и роутеров)
- **[DPI Tunnel for Android](https://github.com/nomoresat/DPITunnel-android)** от @zhenyolka (для Android)
- **[PowerTunnel](https://github.com/krlvm/PowerTunnel)** от @krlvm (для Windows, MacOS и Linux)
- **[PowerTunnel for Android](https://github.com/krlvm/PowerTunnel-Android)** от @krlvm (для Android)
- **[SpoofDPI](https://github.com/xvzc/SpoofDPI)** от @xvzc (для macOS и Linux)
- **[GhosTCP](https://github.com/macronut/ghostcp)** от @macronut (для Windows)
- **[ByeDPI](https://github.com/hufrea/byedpi)** для Linux/Windows + **[ByeDPIAndroid](https://github.com/dovecoteescapee/ByeDPIAndroid/)** для Android (не требуется root)
- **[youtubeUnblock](https://github.com/Waujito/youtubeUnblock/)** от @Waujito (для роутеров на OpenWRT/Entware и Linux)

# Благодарности

Спасибо @basil00 за [WinDivert](https://github.com/basil00/Divert), который представляет собой ядро программы.

Спасибо каждому пользователю прогреммы [BlockCheck](https://github.com/ValdikSS/blockcheck), без отчётов от которых было бы невозможно разобраться во внутреннем поведении DPI-систем.
